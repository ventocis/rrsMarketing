import {
  headingRank
} from "./chunk-K2UY5MOB.js";
import {
  esm_default
} from "./chunk-DGNA47UV.js";
import {
  SKIP,
  visit
} from "./chunk-BQAARP6O.js";
import "./chunk-ZC22LKFR.js";

// node_modules/hast-util-is-element/lib/index.js
var convertElement = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return element;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or array as `test`");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convertElement(tests[index]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function tagNameFactory(check) {
  return castFactory(tagName);
  function tagName(element2) {
    return element2.tagName === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index, parent) {
    return Boolean(
      looksLikeAnElement(value) && testFunction.call(
        this,
        value,
        typeof index === "number" ? index : void 0,
        parent || void 0
      )
    );
  }
}
function element(element2) {
  return Boolean(
    element2 && typeof element2 === "object" && "type" in element2 && element2.type === "element" && "tagName" in element2 && typeof element2.tagName === "string"
  );
}
function looksLikeAnElement(value) {
  return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}

// node_modules/rehype-autolink-headings/lib/index.js
var contentDefaults = {
  type: "element",
  tagName: "span",
  properties: { className: ["icon", "icon-link"] },
  children: []
};
var emptyOptions = {};
function rehypeAutolinkHeadings(options) {
  const settings = options || emptyOptions;
  let properties = settings.properties;
  const headingOroperties = settings.headingProperties;
  const behavior = settings.behavior || "prepend";
  const content = settings.content;
  const group = settings.group;
  const is = convertElement(settings.test);
  let method;
  if (behavior === "after" || behavior === "before") {
    method = around;
  } else if (behavior === "wrap") {
    method = wrap;
  } else {
    method = inject;
    if (!properties) {
      properties = { ariaHidden: "true", tabIndex: -1 };
    }
  }
  return function(tree) {
    visit(tree, "element", function(node, index, parent) {
      if (headingRank(node) && node.properties.id && is(node, index, parent)) {
        Object.assign(node.properties, toProperties(headingOroperties, node));
        return method(node, index, parent);
      }
    });
  };
  function inject(node) {
    const children = toChildren(content || contentDefaults, node);
    node.children[behavior === "prepend" ? "unshift" : "push"](
      create(node, toProperties(properties, node), children)
    );
    return [SKIP];
  }
  function around(node, index, parent) {
    if (typeof index !== "number" || !parent)
      return;
    const children = toChildren(content || contentDefaults, node);
    const link = create(node, toProperties(properties, node), children);
    let nodes = behavior === "before" ? [link, node] : [node, link];
    if (group) {
      const grouping = toNode(group, node);
      if (grouping && !Array.isArray(grouping) && grouping.type === "element") {
        grouping.children = nodes;
        nodes = [grouping];
      }
    }
    parent.children.splice(index, 1, ...nodes);
    return [SKIP, index + nodes.length];
  }
  function wrap(node) {
    let before = node.children;
    let after = [];
    if (typeof content === "function") {
      before = [];
      after = content(node);
    } else if (content) {
      after = clone(content);
    }
    node.children = [
      create(
        node,
        toProperties(properties, node),
        Array.isArray(after) ? [...before, ...after] : [...before, after]
      )
    ];
    return [SKIP];
  }
}
function clone(thing) {
  return (
    /** @type {Cloneable<T>} */
    esm_default(thing)
  );
}
function create(node, properties, children) {
  return {
    type: "element",
    tagName: "a",
    properties: { ...properties, href: "#" + node.properties.id },
    children
  };
}
function toChildren(value, node) {
  const result = toNode(value, node);
  return Array.isArray(result) ? result : [result];
}
function toNode(value, node) {
  if (typeof value === "function")
    return value(node);
  return clone(value);
}
function toProperties(value, node) {
  if (typeof value === "function")
    return value(node);
  return value ? clone(value) : {};
}
export {
  rehypeAutolinkHeadings as default
};
//# sourceMappingURL=rehype-autolink-headings.js.map
